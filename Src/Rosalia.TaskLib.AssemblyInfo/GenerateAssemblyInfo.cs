namespace Rosalia.TaskLib.AssemblyInfo
{
    using System;
    using System.Collections.Generic;
    using System.Globalization;
    using System.Linq;
    using System.Linq.Expressions;
    using Nustache.Core;
    using Rosalia.Core.Tasks;
    using Rosalia.Core.Tasks.Results;
    using Rosalia.FileSystem;

    public class GenerateAssemblyInfo : AbstractTask
    {
        private const string Template =
@"//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

{{#Namespaces}}
using {{Name}};
{{/Namespaces}}

{{#Attributes}}
[assembly: {{Name}}({{{Arguments}}})]
{{/Attributes}}
";

        private readonly IFile _destination;

        public GenerateAssemblyInfo(IFile destination)
        {
            _destination = destination;
            Attributes = new List<Expression<Action<Attribute>>>();
        }

        public IList<Expression<Action<Attribute>>> Attributes { get; private set; }

        private IEnumerable<string> GetArgumetValues(NewExpression body)
        {
            foreach (var expression in body.Arguments)
            {
                var dynamicArg = Expression.Lambda(expression).Compile().DynamicInvoke();

                //// It turned out that .NET has no clear way to get string representation
                //// of the expression. So we have no other options but handle each case manually.
                if (dynamicArg is string)
                {
                    yield return string.Format("\"{0}\"", dynamicArg);
                }
                else if (dynamicArg is bool)
                {
                    yield return ((bool) dynamicArg) ? "true" : "false";
                }
                /* todo: more options here if needed */
                else
                {
                    yield return Convert.ToString(dynamicArg, CultureInfo.InvariantCulture);
                }
            }
        }

        internal class Namespace
        {
            public string Name { get; set; }
        }

        internal class AttributeInfo
        {
            public string Name { get; set; }

            public string Arguments { get; set; }
        }

        internal class Model
        {
            public IList<Namespace> Namespaces { get; set; }

            public IList<AttributeInfo> Attributes { get; set; }
        }

        protected override ITaskResult<Nothing> SafeExecute(TaskContext context)
        {
            if (_destination == null)
            {
                throw new Exception("Destination file could not be null");
            }

            _destination.EnsureExists();

            var model = new Model
            {
                Attributes = new List<AttributeInfo>(),
                Namespaces = new List<Namespace>()
            };

            foreach (var attributeExpression in Attributes)
            {
                var body = (NewExpression)attributeExpression.Body;
                var attributeInfo = new AttributeInfo();

                var namespaceName = body.Type.Namespace;

                if (model.Namespaces.All(n => n.Name != namespaceName))
                {
                    model.Namespaces.Add(new Namespace
                    {
                        Name = namespaceName
                    });
                }

                attributeInfo.Name = body.Type.Name;
                attributeInfo.Arguments = string.Join(", ", GetArgumetValues(body));

                model.Attributes.Add(attributeInfo);
            }

            var result = Render.StringToString(Template, model);

            _destination.EnsureExists();
            _destination.WriteStringToFile(result);

            return Success;
        }
    }
}